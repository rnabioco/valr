<!-- Generated by staticdocs: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<title><code>valr</code>: Genome interval arithmetic in R. valr</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>

<!-- Bootstrap -->
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">


<!-- staticdocs -->
<link href="../staticdocs.css" rel="stylesheet">
<script src="../staticdocs.js"></script>

<!-- mathjax -->
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
  </head>

  <body>
    <div class="container">
        <header>
        
<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">valr</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../articles/valr-overview.html">Overview</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jayhesselberth/valr">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
        
        </header>

        
<div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1><code>valr</code>: Genome interval arithmetic in R</h1>
                        <h4 class="author">Jay Hesselberth <a href="mailto:jay.hesselberth@gmail.com">jay.hesselberth@gmail.com</a></h4>
            
            <h4 class="date">2016-10-01</h4>
          </div>

    
    
<div id="overview" class="section level1">
<h1>Overview</h1>
<p><code>valr</code> provides tools to read and manipulate genome intervals and signals, similar to the standalone <a href="http://bedtools.readthedocs.org/en/latest/"><code>BEDtools</code></a> suite. <code>valr</code> enables BEDtools-like analysis in the R/RStudio environment, and uses modern R tools for a terse, expressive syntax. Compute-intensive algorithms are implemented in <a href="http://www.rcpp.org/"><code>Rcpp</code></a>/C++, and many methods take advantage of the speed and grouping capability provided by <a href="https://github.com/hadley/dplyr"><code>dplyr</code></a>.</p>
<p>We provide several introductions to <code>valr</code>:</p>
<ul>
<li>This comprehensive <code>vignette</code> covering the core methods.</li>
<li>A tutorial that demonstrates how to use <code>valr</code> in “real-world” applications.</li>
<li>A <code>shiny</code> application that demonstrates interactive analysis of genome-scale data sets.</li>
</ul>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p><code>valr</code> can be installed from github, and will be eventually deposited in CRAN.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">devtools::<span class="kw">install_github</span>(<span class="st">&#39;jayhesselberth/valr&#39;</span>)</code></pre></div>
</div>
<div id="comparison-to-other-tools" class="section level2">
<h2>Comparison to other tools</h2>
<p><strong>Why another tool set for interval manipulations?</strong> We already have <a href="http://bedtools.readthedocs.org/en/latest/">BEDtools</a>, <a href="http://bedops.readthedocs.org/en/latest/index.html">bedops</a>, <a href="https://pythonhosted.org/pybedtools/">pybedtools</a>, <a href="https://bioconductor.org/packages/release/bioc/html/GenomicRanges.html">GenomicRanges</a>, <a href="https://cran.r-project.org/web/packages/bedr/index.html">bedr</a> and <a href="https://bioconductor.org/packages/release/bioc/html/IRanges.html">IRanges</a>.</p>
<p>We were motivated to develop a toolset that:</p>
<ul>
<li>Combines analysis and visualization in RStudio.</li>
<li>Can be used to generate reports with Rmarkdown.</li>
<li>Is highly extensible. New tools are quickly implemented on the R side.</li>
<li>Leverages the “modern R” syntax, using <code>dplyr</code> and the pipe operator from <code>magrittr</code> (<code>%&gt;%</code>).</li>
<li>Maximizes speed by implementing compute-intensive algorithms in <code>Rcpp</code>.</li>
<li>Facilitates interactive visulaizations with <a href="http://shiny.rstudio.com/"><code>shiny</code></a>.</li>
</ul>
<p>We anticipate <code>valr</code> will mainly be used for analysis of pre-processed data in BED, bedGraph and VCF formats. Most users will have processed their aligned reads from BAM format to bedGraph, so we do not foresee supporting BAM directly. We would entertain requests for GTF / GFF support if there is interest, as <code>tidyr</code> makes it easy to convert these to BED12.</p>
<p>Certain algorithms in <code>valr</code> were implemented in <code>Rcpp</code> (including <a href="https://github.com/jayhesselberth/valr/tree/master/src">intersect, merge, subtract, closest</a>) to enable fluid interactive analysis. See the <a href="#benchmarks">benchmarks</a> section for details.</p>
</div>
<div id="non-standard-evaluation" class="section level2">
<h2>Non-standard evaluation</h2>
<p>Several of the methods in <code>valr</code> use <a href="https://cran.r-project.org/web/packages/dplyr/vignettes/nse.html">NSE</a> for an expressive syntax. Columns are referred to by name and can be used in multiple name/value expressions for summaries.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_map</span>(x, y, <span class="dt">mean =</span> <span class="kw">mean</span>(value), <span class="dt">var =</span> <span class="kw">var</span>(value))
<span class="kw">bed_merge</span>(x, <span class="dt">concat =</span> <span class="kw">concat</span>(value), <span class="dt">max =</span> <span class="kw">max</span>(value))</code></pre></div>
</div>
<div id="getting-started" class="section level2">
<h2>Getting started</h2>
<p>Here is an example using <code>valr</code> that creates</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(valr)</code></pre></div>
</div>
</div>
<div id="reading-data" class="section level1 tabset">
<h1>Reading data</h1>
<p><code>valr</code> has several methods to read interval data. These methods:</p>
<ul>
<li>Take local files or URLs as input.</li>
<li>Return a <code>data.frame</code> in <code>tibble::tbl_df</code> format.</li>
<li>Assign consistent <code>chrom</code>, <code>start</code> and <code>end</code> column names.</li>
<li>Use <a href="https://github.com/hadley/readr"><code>readr</code></a> for speed.</li>
<li>Coerce column types.</li>
</ul>
<p>The methods include:</p>
<ul>
<li><code>read_bed()</code>: read a BED3+ file</li>
<li><code>read_bed12()</code>: read a BED12 file</li>
<li><code>read_bedgraph()</code>: read a bedGraph file</li>
<li><code>read_genome()</code>: read a UCSC “chrom size” file</li>
<li><code>read_vcf()</code>: read the Variant Call Format</li>
<li><code>read_narrowpeak()</code>: read narrowPeak files</li>
<li><code>read_broadpeak()</code>: read broadPeak files</li>
</ul>
<div id="bed-files" class="section level2">
<h2>BED files</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_bed</span>(<span class="kw">valr_example</span>(<span class="st">&#39;3fields.bed.gz&#39;</span>))
<span class="co">#&gt; # A tibble: 10 × 3</span>
<span class="co">#&gt;    chrom  start    end</span>
<span class="co">#&gt;    &lt;chr&gt;  &lt;int&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  11873  14409</span>
<span class="co">#&gt; 2   chr1  14361  19759</span>
<span class="co">#&gt; 3   chr1  14406  29370</span>
<span class="co">#&gt; 4   chr1  34610  36081</span>
<span class="co">#&gt; 5   chr1  69090  70008</span>
<span class="co">#&gt; 6   chr1 134772 140566</span>
<span class="co">#&gt; 7   chr1 321083 321115</span>
<span class="co">#&gt; 8   chr1 321145 321207</span>
<span class="co">#&gt; 9   chr1 322036 326938</span>
<span class="co">#&gt; 10  chr1 327545 328439</span>
<span class="kw">read_bed</span>(<span class="dt">n_fields =</span> <span class="dv">6</span>, <span class="kw">valr_example</span>(<span class="st">&#39;6fields.bed.gz&#39;</span>))
<span class="co">#&gt; # A tibble: 10 × 6</span>
<span class="co">#&gt;    chrom  start    end         name score strand</span>
<span class="co">#&gt;    &lt;chr&gt;  &lt;int&gt;  &lt;int&gt;        &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;</span>
<span class="co">#&gt; 1   chr1  11873  14409      DDX11L1     3      +</span>
<span class="co">#&gt; 2   chr1  14361  19759       WASH7P    10      -</span>
<span class="co">#&gt; 3   chr1  14406  29370       WASH7P     7      -</span>
<span class="co">#&gt; 4   chr1  34610  36081      FAM138F     3      -</span>
<span class="co">#&gt; 5   chr1  69090  70008        OR4F5     1      +</span>
<span class="co">#&gt; 6   chr1 134772 140566    LOC729737     3      -</span>
<span class="co">#&gt; 7   chr1 321083 321115     DQ597235     1      +</span>
<span class="co">#&gt; 8   chr1 321145 321207     DQ599768     1      +</span>
<span class="co">#&gt; 9   chr1 322036 326938 LOC100133331     3      +</span>
<span class="co">#&gt; 10  chr1 327545 328439    LOC388312     1      +</span>
<span class="kw">read_bed12</span>(<span class="kw">valr_example</span>(<span class="st">&#39;12fields.bed.gz&#39;</span>))
<span class="co">#&gt; # A tibble: 3 × 12</span>
<span class="co">#&gt;   chrom   start     end      name score strand cds_start cds_end item_rgb</span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;    &lt;chr&gt;</span>
<span class="co">#&gt; 1  chr1 4797973 4836816  testgene     1      +   4797973 4836816        .</span>
<span class="co">#&gt; 2 chr10 4848118 4880877 diffchrom     1      +   4848118 4880877        .</span>
<span class="co">#&gt; 3 chr20 5073253 5152630 negstrand     1      -   5073253 5152630        .</span>
<span class="co">#&gt; # ... with 3 more variables: exon_count &lt;int&gt;, exon_sizes &lt;chr&gt;,</span>
<span class="co">#&gt; #   exon_starts &lt;chr&gt;</span></code></pre></div>
</div>
<div id="genome-files" class="section level2">
<h2>Genome files</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">genome &lt;-<span class="st"> </span><span class="kw">read_genome</span>(<span class="kw">valr_example</span>(<span class="st">&#39;hg19.chrom.sizes.gz&#39;</span>))</code></pre></div>
</div>
<div id="bedgraph-files" class="section level2">
<h2>bedGraph files</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_bedgraph</span>(<span class="kw">valr_example</span>(<span class="st">&#39;test.bg.gz&#39;</span>))
<span class="co">#&gt; # A tibble: 4 × 4</span>
<span class="co">#&gt;   chrom    start      end value</span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;int&gt;    &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 chr19 49302000 49302300 -1.00</span>
<span class="co">#&gt; 2 chr19 49302300 49302600 -0.75</span>
<span class="co">#&gt; 3 chr19 49302600 49302900 -0.50</span>
<span class="co">#&gt; 4 chr19 49302900 49303200 -0.25</span></code></pre></div>
</div>
<div id="vcf-files" class="section level2">
<h2>VCF files</h2>
<p><code>read_vcf()</code> reads VCF files and assigns <code>chrom</code>, <code>start</code> and <code>end</code> columns to be used to downstream interval comparisons. Note the interval size is calculated as the length of the <code>REF</code> field in the original file.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_vcf</span>(<span class="kw">valr_example</span>(<span class="st">&#39;test.vcf.gz&#39;</span>))
<span class="co">#&gt; # A tibble: 115 × 201</span>
<span class="co">#&gt;    CHROM   POS    ID                                          REF</span>
<span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;                                        &lt;chr&gt;</span>
<span class="co">#&gt; 1      1 10172     .                                       CCCTAA</span>
<span class="co">#&gt; 2      1 10390     . CCCCTAACCCCTAACCCTAACCCTAACCCTAACCCTAACCCTAA</span>
<span class="co">#&gt; 3      1 10397     .                                CCCCTAACCCTAA</span>
<span class="co">#&gt; 4      1 10403     .       ACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 5      1 10409     .             ACCCTAACCCTAACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 6      1 10415     .                   ACCCTAACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 7      1 10421     .                         ACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 8      1 10428     .                                       CCCTAA</span>
<span class="co">#&gt; 9      1 10440     .                                            C</span>
<span class="co">#&gt; 10     1 10478     .                                            C</span>
<span class="co">#&gt; # ... with 105 more rows, and 197 more variables: ALT &lt;chr&gt;, QUAL &lt;dbl&gt;,</span>
<span class="co">#&gt; #   FILTER &lt;chr&gt;, INFO &lt;chr&gt;, FORMAT &lt;chr&gt;, `101976-101976` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100920-100920` &lt;chr&gt;, `100231-100231` &lt;chr&gt;, `100232-100232` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100919-100919` &lt;chr&gt;, `101977-101977` &lt;chr&gt;, `100630-100630` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100640-100640` &lt;chr&gt;, `100631-100631` &lt;chr&gt;, `101583-101583` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101584-101584` &lt;chr&gt;, `101732-101732` &lt;chr&gt;, `101016-101016` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101708-101708` &lt;chr&gt;, `101730-101730` &lt;chr&gt;, `101582-101582` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101731-101731` &lt;chr&gt;, `101809-101809` &lt;chr&gt;, `101653-101653` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101652-101652` &lt;chr&gt;, `101806-101806` &lt;chr&gt;, `101807-101807` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101808-101808` &lt;chr&gt;, `101810-101810` &lt;chr&gt;, `101811-101811` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101812-101812` &lt;chr&gt;, `101813-101813` &lt;chr&gt;, `101814-101814` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101957-101957` &lt;chr&gt;, `101958-101958` &lt;chr&gt;, `100986-100986` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100987-100987` &lt;chr&gt;, `101897-101897` &lt;chr&gt;, `102071-102071` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102106-102106` &lt;chr&gt;, `101040-101040` &lt;chr&gt;, `101167-101167` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101041-101041` &lt;chr&gt;, `101042-101042` &lt;chr&gt;, `101168-101168` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101898-101898` &lt;chr&gt;, `102070-102070` &lt;chr&gt;, `102111-102111` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100988-100988` &lt;chr&gt;, `101896-101896` &lt;chr&gt;, `102110-102110` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102620-102620` &lt;chr&gt;, `102621-102621` &lt;chr&gt;, `102947-102947` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102948-102948` &lt;chr&gt;, `103089-103089` &lt;chr&gt;, `102693-102693` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102694-102694` &lt;chr&gt;, `102949-102949` &lt;chr&gt;, `102622-102622` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102623-102623` &lt;chr&gt;, `102624-102624` &lt;chr&gt;, `102722-102722` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102712-102712` &lt;chr&gt;, `103339-103339` &lt;chr&gt;, `103124-103124` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `103161-103161` &lt;chr&gt;, `103125-103125` &lt;chr&gt;, `103171-103171` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `103338-103338` &lt;chr&gt;, `103372-103372` &lt;chr&gt;, `103193-103193` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100195-100195` &lt;chr&gt;, `100194-100194` &lt;chr&gt;, `101667-101667` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101137-101137` &lt;chr&gt;, `101291-101291` &lt;chr&gt;, `101292-101292` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101666-101666` &lt;chr&gt;, `32222-32222` &lt;chr&gt;, `32049-32049` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `32050-32050` &lt;chr&gt;, `32411-32411` &lt;chr&gt;, `32221-32221` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100147-100147` &lt;chr&gt;, `100149-100149` &lt;chr&gt;, `100243-100243` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100290-100290` &lt;chr&gt;, `100753-100753` &lt;chr&gt;, `100754-100754` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101377-101377` &lt;chr&gt;, `101426-101426` &lt;chr&gt;, `101435-101435` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101523-101523` &lt;chr&gt;, `101877-101877` &lt;chr&gt;, `100043-100043` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100044-100044` &lt;chr&gt;, `100148-100148` &lt;chr&gt;, `100292-100292` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101381-101381` &lt;chr&gt;, ...</span></code></pre></div>
</div>
</div>
<div id="interval-manipulations" class="section level1">
<h1>Interval manipulations</h1>
<p><code>valr</code> implements several methods for manipulating sets of intervals. Some methods operate on a single set of intervals, while others compare two sets of intervals.</p>
<p>Many methods the same name as the corresponding <code>BEDtool</code>, and some commonly used <code>BEDtools</code> are implemented as <code>dplyr</code> pipes (e.g., see the <a href="#groupby"><code>group_by</code></a> section).</p>
<p>All methods accept one or more sets of <code>x</code> and <code>y</code> intervals, which must either be created using the <a href="#reading%20data"><code>read</code> methods</a>, or have <code>chrom</code>, <code>start</code> and <code>end</code> columns.</p>
<div id="single-set-operations" class="section level2 tabset">
<h2>Single set operations</h2>
<p>These methods operate on a single set of intervals:</p>
<ul>
<li><code>bed_sort()</code>: order intervals</li>
<li><code>bed_cluster()</code>: Cluster (but don’t merge) overlapping/nearby intervals.</li>
<li><code>bed_complement()</code>: extract intervals <em>not</em> represented by an interval file.</li>
<li><code>bed_merge()</code>: combine overlapping and nearby intervals into a single interval.</li>
<li><code>bed_flank()</code>: Generate new flanking intervals</li>
<li><code>bed_slop()</code>: Expand the size of input intervals</li>
<li><code>bed_shift()</code>: Shift the coordinates of an input set, bounded by a genome</li>
</ul>
<div id="sort" class="section level3">
<h3>Sort</h3>
<p><code>bed_sort</code> orders intervals based on a specification. <code>is_sorted</code> asks whether a tbl is already sorted.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
<span class="kw">is_sorted</span>(x)
<span class="co">#&gt; [1] FALSE</span>

y &lt;-<span class="st"> </span><span class="kw">bed_sort</span>(x)
y
<span class="co">#&gt; # A tibble: 1,000,000 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  2013  3013</span>
<span class="co">#&gt; 2   chr1  3707  4707</span>
<span class="co">#&gt; 3   chr1  4175  5175</span>
<span class="co">#&gt; 4   chr1  5390  6390</span>
<span class="co">#&gt; 5   chr1 21263 22263</span>
<span class="co">#&gt; 6   chr1 22460 23460</span>
<span class="co">#&gt; 7   chr1 24283 25283</span>
<span class="co">#&gt; 8   chr1 28285 29285</span>
<span class="co">#&gt; 9   chr1 28298 29298</span>
<span class="co">#&gt; 10  chr1 28486 29486</span>
<span class="co">#&gt; # ... with 999,990 more rows</span>

<span class="kw">is_sorted</span>(y)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
</div>
<div id="cluster" class="section level3">
<h3>Cluster</h3>
<p><code>bed_cluster</code> identifies clustered intervals based on a distance specification and assigns them a unique <code>.id</code>.</p>
<p><img src="README-cluster_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_cluster</span>(x, <span class="dt">max_dist =</span> <span class="dv">1000</span>)
y
<span class="co">#&gt; # A tibble: 1,000,000 × 4</span>
<span class="co">#&gt;    chrom     start       end   .id</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1  chr15  27340860  27341860  8914</span>
<span class="co">#&gt; 2   chr4 154683840 154684840 49997</span>
<span class="co">#&gt; 3   chr3 160658822 160659822 51951</span>
<span class="co">#&gt; 4  chr19    930859    931859   311</span>
<span class="co">#&gt; 5   chrX  81997426  81998426 26461</span>
<span class="co">#&gt; 6  chr10  22078941  22079941  7318</span>
<span class="co">#&gt; 7  chr20  22747303  22748303  7259</span>
<span class="co">#&gt; 8  chr17  40361291  40362291 13402</span>
<span class="co">#&gt; 9   chr1  57154583  57155583 18509</span>
<span class="co">#&gt; 10  chr5  30534211  30535211  9739</span>
<span class="co">#&gt; # ... with 999,990 more rows</span></code></pre></div>
</div>
<div id="complement" class="section level3">
<h3>Complement</h3>
<p><code>bed_complement</code> identifies intervals in a genome that are not covered by an input.</p>
<p><img src="README-complement_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_complement</span>(x, genome)
<span class="co">#&gt; # A tibble: 724,132 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1     1   938</span>
<span class="co">#&gt; 2   chr1  1938  2066</span>
<span class="co">#&gt; 3   chr1  4002  6113</span>
<span class="co">#&gt; 4   chr1  7113  8528</span>
<span class="co">#&gt; 5   chr1  9528 14574</span>
<span class="co">#&gt; 6   chr1 15574 19699</span>
<span class="co">#&gt; 7   chr1 20699 23693</span>
<span class="co">#&gt; 8   chr1 24693 30826</span>
<span class="co">#&gt; 9   chr1 31826 34230</span>
<span class="co">#&gt; 10  chr1 35230 45605</span>
<span class="co">#&gt; # ... with 724,122 more rows</span></code></pre></div>
</div>
<div id="merge" class="section level3">
<h3>Merge</h3>
<p><code>bed_merge</code> identifies overlapping intervals and reports new merged ones. <code>is_merged</code> asks whether a tbl is already merged. Values from merged intervals can be reported using name / value pairs.</p>
<p><img src="README-merge_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="fl">1e6</span>
x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> n)
<span class="kw">is_merged</span>(x)
<span class="co">#&gt; [1] FALSE</span>

<span class="co"># add some signal</span>
x &lt;-<span class="st"> </span>x %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">signal =</span> <span class="kw">runif</span>(n))

<span class="kw">bed_merge</span>(x, <span class="dt">maxs =</span> <span class="kw">max</span>(signal))
<span class="co">#&gt; # A tibble: 723,547 × 4</span>
<span class="co">#&gt;    chrom start   end      maxs</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1   chr1  2500  3500 0.1564948</span>
<span class="co">#&gt; 2   chr1  8704  9704 0.1222498</span>
<span class="co">#&gt; 3   chr1 13645 14645 0.5203007</span>
<span class="co">#&gt; 4   chr1 14683 15683 0.2399135</span>
<span class="co">#&gt; 5   chr1 21090 22090 0.4726709</span>
<span class="co">#&gt; 6   chr1 32726 33726 0.5562754</span>
<span class="co">#&gt; 7   chr1 39820 40820 0.7837789</span>
<span class="co">#&gt; 8   chr1 41156 42309 0.8239328</span>
<span class="co">#&gt; 9   chr1 45146 46146 0.7291011</span>
<span class="co">#&gt; 10  chr1 47733 49841 0.2221369</span>
<span class="co">#&gt; # ... with 723,537 more rows</span></code></pre></div>
</div>
<div id="flank" class="section level3">
<h3>Flank</h3>
<p><code>bed_flank</code> creates new intervals that flank – but do not contain – the input intervals.</p>
<p><img src="README-flank_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_flank</span>(x, genome, <span class="dt">both  =</span> <span class="dv">100</span>)
<span class="co">#&gt; # A tibble: 2,000,000 × 4</span>
<span class="co">#&gt;    chrom start   end    signal</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1   chr1  2400  2500 0.1564948</span>
<span class="co">#&gt; 2   chr1  3500  3600 0.1564948</span>
<span class="co">#&gt; 3   chr1  8604  8704 0.1222498</span>
<span class="co">#&gt; 4   chr1  9704  9804 0.1222498</span>
<span class="co">#&gt; 5   chr1 13545 13645 0.5203007</span>
<span class="co">#&gt; 6   chr1 14583 14683 0.2399135</span>
<span class="co">#&gt; 7   chr1 14645 14745 0.5203007</span>
<span class="co">#&gt; 8   chr1 15683 15783 0.2399135</span>
<span class="co">#&gt; 9   chr1 20990 21090 0.4726709</span>
<span class="co">#&gt; 10  chr1 22090 22190 0.4726709</span>
<span class="co">#&gt; # ... with 1,999,990 more rows</span></code></pre></div>
</div>
<div id="slop" class="section level3">
<h3>Slop</h3>
<p><code>bed_slop</code> pads input intervals based on a specification</p>
<p><img src="README-slop_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_slop</span>(x, genome, <span class="dt">both =</span> <span class="dv">100</span>)
<span class="co">#&gt; # A tibble: 1,000,000 × 4</span>
<span class="co">#&gt;    chrom start   end     signal</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1   chr1  2400  3600 0.15649481</span>
<span class="co">#&gt; 2   chr1  8604  9804 0.12224982</span>
<span class="co">#&gt; 3   chr1 13545 14745 0.52030070</span>
<span class="co">#&gt; 4   chr1 14583 15783 0.23991352</span>
<span class="co">#&gt; 5   chr1 20990 22190 0.47267087</span>
<span class="co">#&gt; 6   chr1 32626 33826 0.55627541</span>
<span class="co">#&gt; 7   chr1 39720 40920 0.78377891</span>
<span class="co">#&gt; 8   chr1 41056 42256 0.04300769</span>
<span class="co">#&gt; 9   chr1 41209 42409 0.82393277</span>
<span class="co">#&gt; 10  chr1 45046 46246 0.72910115</span>
<span class="co">#&gt; # ... with 999,990 more rows</span></code></pre></div>
</div>
<div id="shift" class="section level3">
<h3>Shift</h3>
<p><code>bed_shift</code> adjusts coordinates toward <code>start</code> or <code>end</code> by a defined <code>size</code>. Intervals created out of bounds are removed, or trimmed.</p>
<p><img src="README-shift_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_shift</span>(x, genome, <span class="dt">size =</span> <span class="dv">100</span>)
<span class="co">#&gt; # A tibble: 1,000,000 × 4</span>
<span class="co">#&gt;    chrom     start       end     signal</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1  chr13  16476999  16477999 0.74152153</span>
<span class="co">#&gt; 2  chr11  13974805  13975805 0.05144628</span>
<span class="co">#&gt; 3  chr10  44318556  44319556 0.53021246</span>
<span class="co">#&gt; 4   chr8 111302723 111303723 0.69582388</span>
<span class="co">#&gt; 5  chr14  80394414  80395414 0.68855600</span>
<span class="co">#&gt; 6   chr4  13210366  13211366 0.03123033</span>
<span class="co">#&gt; 7   chr5 142280665 142281665 0.22556253</span>
<span class="co">#&gt; 8   chr3  91415530  91416530 0.30083081</span>
<span class="co">#&gt; 9   chr1 208900124 208901124 0.63646561</span>
<span class="co">#&gt; 10  chr4 145029883 145030883 0.47902455</span>
<span class="co">#&gt; # ... with 999,990 more rows</span></code></pre></div>
</div>
<div id="interval-spacing" class="section level3">
<h3>Interval spacing</h3>
<p>Interval spacing is easily computed using <code>dplyr</code>. Overlapping intervals must first be merged. Spacing for the first interval of each chromosome is undefined.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
x &lt;-<span class="st"> </span><span class="kw">bed_merge</span>(x)

x %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(chrom) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">.spacing =</span> start -<span class="st"> </span><span class="kw">lag</span>(end))
<span class="co">#&gt; Source: local data frame [724,013 x 4]</span>
<span class="co">#&gt; Groups: chrom [25]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom start   end .spacing</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1   651  2656       NA</span>
<span class="co">#&gt; 2   chr1  4871  5871     2215</span>
<span class="co">#&gt; 3   chr1  7846  8846     1975</span>
<span class="co">#&gt; 4   chr1  9268 10268      422</span>
<span class="co">#&gt; 5   chr1 16404 17404     6136</span>
<span class="co">#&gt; 6   chr1 17626 18626      222</span>
<span class="co">#&gt; 7   chr1 27256 28723     8630</span>
<span class="co">#&gt; 8   chr1 32502 33773     3779</span>
<span class="co">#&gt; 9   chr1 41062 42062     7289</span>
<span class="co">#&gt; 10  chr1 42358 43358      296</span>
<span class="co">#&gt; # ... with 724,003 more rows</span></code></pre></div>
</div>
</div>
<div id="multiple-set-operations" class="section level2 tabset">
<h2>Multiple set operations</h2>
<p>These methods compare two sets of intervals:</p>
<ul>
<li><code>bed_intersect()</code>: find overlapping intervals</li>
<li><code>bed_map()</code>: apply a function to selected columns for overlapping intervals</li>
<li><code>bed_subtract()</code>: Remove intervals based on overlaps between two files</li>
<li><code>bed_window()</code>: Find overlapping intervals within a window</li>
<li><code>bed_closest()</code>: find the closest intervals independent of overlaps</li>
</ul>
<div id="intersection" class="section level3">
<h3>Intersection</h3>
<p><code>bed_intersect</code> is implemented using an <a href="https://github.com/ekg/intervaltree/">interval tree</a> in <code>Rcpp</code>. Column names in the result have <code>.x</code> and <code>.y</code> suffixes, and an <code>.overlap</code> column contains the size of the intersection (values of <code>0</code> indicate book-ended, or touching intervals). See the <a href="#benchmarks">benchmarks</a> section for timing. Though <code>bed_intersect</code> is pretty fast already, we intend to further improve upon this by parallization with <a href="https://rcppcore.github.io/RcppParallel/"><code>RcppParallel</code></a>.</p>
<p><img src="README-intersect_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># intersect two sets of 1e6 intervals from hg19</span>
x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_intersect</span>(x, y)
<span class="co">#&gt; # A tibble: 647,258 × 6</span>
<span class="co">#&gt;    chrom start.x end.x start.y end.y .overlap</span>
<span class="co">#&gt;    &lt;chr&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1   24102 25102   23669 24669      567</span>
<span class="co">#&gt; 2   chr1   24102 25102   24538 25538      564</span>
<span class="co">#&gt; 3   chr1   41156 42156   42140 43140       16</span>
<span class="co">#&gt; 4   chr1   42365 43365   42140 43140      775</span>
<span class="co">#&gt; 5   chr1   42365 43365   42729 43729      636</span>
<span class="co">#&gt; 6   chr1   44327 45327   44203 45203      876</span>
<span class="co">#&gt; 7   chr1   44327 45327   44239 45239      912</span>
<span class="co">#&gt; 8   chr1   59363 60363   60073 61073      290</span>
<span class="co">#&gt; 9   chr1   65308 66308   64868 65868      560</span>
<span class="co">#&gt; 10  chr1   66312 67312   66818 67818      494</span>
<span class="co">#&gt; # ... with 647,248 more rows</span>

<span class="co"># A records with no overlaps (i.e., `-v`)</span>
<span class="kw">bed_intersect</span>(x, y, <span class="dt">invert =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; Source: local data frame [523,952 x 3]</span>
<span class="co">#&gt; Groups: chrom [25]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom    start      end</span>
<span class="co">#&gt;    &lt;chr&gt;    &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1   chrY 59352572 59353572</span>
<span class="co">#&gt; 2   chrY 59348610 59349610</span>
<span class="co">#&gt; 3   chrY 59347839 59348839</span>
<span class="co">#&gt; 4   chrY 59343083 59344083</span>
<span class="co">#&gt; 5   chrY 59319715 59320715</span>
<span class="co">#&gt; 6   chrY 59318945 59319945</span>
<span class="co">#&gt; 7   chrY 59318150 59319150</span>
<span class="co">#&gt; 8   chrY 59308226 59309226</span>
<span class="co">#&gt; 9   chrY 59296939 59297939</span>
<span class="co">#&gt; 10  chrY 59286391 59287391</span>
<span class="co">#&gt; # ... with 523,942 more rows</span></code></pre></div>
<p>One can achieve behaviour similar to BEDtools by combining <code>bed_intersect</code> with <code>dplyr</code> tools.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `x` records with overlaps (i.e., `-wa`)</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">select</span>(chrom, <span class="dt">start =</span> start.x, <span class="dt">end =</span> end.x)
<span class="co">#&gt; # A tibble: 647,258 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 24102 25102</span>
<span class="co">#&gt; 2   chr1 24102 25102</span>
<span class="co">#&gt; 3   chr1 41156 42156</span>
<span class="co">#&gt; 4   chr1 42365 43365</span>
<span class="co">#&gt; 5   chr1 42365 43365</span>
<span class="co">#&gt; 6   chr1 44327 45327</span>
<span class="co">#&gt; 7   chr1 44327 45327</span>
<span class="co">#&gt; 8   chr1 59363 60363</span>
<span class="co">#&gt; 9   chr1 65308 66308</span>
<span class="co">#&gt; 10  chr1 66312 67312</span>
<span class="co">#&gt; # ... with 647,248 more rows</span>

<span class="co"># `y` records with overlaps (i.e., `-wb`)</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">select</span>(chrom, <span class="dt">start =</span> start.y, <span class="dt">end =</span> end.y)
<span class="co">#&gt; # A tibble: 647,258 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 23669 24669</span>
<span class="co">#&gt; 2   chr1 24538 25538</span>
<span class="co">#&gt; 3   chr1 42140 43140</span>
<span class="co">#&gt; 4   chr1 42140 43140</span>
<span class="co">#&gt; 5   chr1 42729 43729</span>
<span class="co">#&gt; 6   chr1 44203 45203</span>
<span class="co">#&gt; 7   chr1 44239 45239</span>
<span class="co">#&gt; 8   chr1 60073 61073</span>
<span class="co">#&gt; 9   chr1 64868 65868</span>
<span class="co">#&gt; 10  chr1 66818 67818</span>
<span class="co">#&gt; # ... with 647,248 more rows</span>

<span class="co"># Unique records in `x` (i.e., `-u`)</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">select</span>(chrom, <span class="dt">start =</span> start.x, <span class="dt">end =</span> end.x) %&gt;%<span class="st"> </span><span class="kw">unique</span>()
<span class="co">#&gt; # A tibble: 475,978 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 24102 25102</span>
<span class="co">#&gt; 2   chr1 41156 42156</span>
<span class="co">#&gt; 3   chr1 42365 43365</span>
<span class="co">#&gt; 4   chr1 44327 45327</span>
<span class="co">#&gt; 5   chr1 59363 60363</span>
<span class="co">#&gt; 6   chr1 65308 66308</span>
<span class="co">#&gt; 7   chr1 66312 67312</span>
<span class="co">#&gt; 8   chr1 72546 73546</span>
<span class="co">#&gt; 9   chr1 92780 93780</span>
<span class="co">#&gt; 10  chr1 93479 94479</span>
<span class="co">#&gt; # ... with 475,968 more rows</span>

<span class="co"># Count `y` intervals that intersect each `x` interval</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">group_by</span>(chrom, start.x, end.x) %&gt;%<span class="st"> </span><span class="kw">summarize</span>(<span class="dt">count =</span> <span class="kw">n</span>())
<span class="co">#&gt; Source: local data frame [475,978 x 4]</span>
<span class="co">#&gt; Groups: chrom, start.x [?]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom start.x end.x count</span>
<span class="co">#&gt;    &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1   24102 25102     2</span>
<span class="co">#&gt; 2   chr1   41156 42156     1</span>
<span class="co">#&gt; 3   chr1   42365 43365     2</span>
<span class="co">#&gt; 4   chr1   44327 45327     2</span>
<span class="co">#&gt; 5   chr1   59363 60363     1</span>
<span class="co">#&gt; 6   chr1   65308 66308     1</span>
<span class="co">#&gt; 7   chr1   66312 67312     3</span>
<span class="co">#&gt; 8   chr1   72546 73546     1</span>
<span class="co">#&gt; 9   chr1   92780 93780     1</span>
<span class="co">#&gt; 10  chr1   93479 94479     1</span>
<span class="co">#&gt; # ... with 475,968 more rows</span></code></pre></div>
</div>
<div id="map" class="section level3">
<h3>Map</h3>
<p><code>bed_map</code> maps signals onto intervals. Summary statistics for mapped signals can be specific using NSE with name / value pairs.</p>
<pre><code>#&gt; Warning: Removed 1 rows containing missing values (geom_label).</code></pre>
<p><img src="README-map_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bedfile &lt;-<span class="st"> </span><span class="kw">valr_example</span>(<span class="st">&#39;genes.hg19.chr22.bed.gz&#39;</span>)
bgfile  &lt;-<span class="st"> </span><span class="kw">valr_example</span>(<span class="st">&#39;hela.h3k4.chip.bg.gz&#39;</span>)

x &lt;-<span class="st"> </span><span class="kw">read_bed</span>(bedfile, <span class="dt">n_fields =</span> <span class="dv">6</span>)
y &lt;-<span class="st"> </span><span class="kw">read_bedgraph</span>(bgfile)

<span class="kw">bed_map</span>(x, y, <span class="dt">means =</span> <span class="kw">mean</span>(value.y), <span class="dt">sds =</span> <span class="kw">sd</span>(value.y))
<span class="co">#&gt; # A tibble: 591 × 5</span>
<span class="co">#&gt;    chrom  start.x    end.x    means       sds</span>
<span class="co">#&gt;    &lt;chr&gt;    &lt;int&gt;    &lt;int&gt;    &lt;dbl&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1  chr22 16150259 16193004 7.914286 7.5707309</span>
<span class="co">#&gt; 2  chr22 16162065 16172265 1.000000        NA</span>
<span class="co">#&gt; 3  chr22 16256331 16287937 1.000000 0.0000000</span>
<span class="co">#&gt; 4  chr22 17071647 17073700 1.000000 0.0000000</span>
<span class="co">#&gt; 5  chr22 17082800 17129720 1.117647 0.3270350</span>
<span class="co">#&gt; 6  chr22 17134598 17156430 1.294118 0.5878675</span>
<span class="co">#&gt; 7  chr22 17227758 17229328 1.000000        NA</span>
<span class="co">#&gt; 8  chr22 17264305 17302584 1.250000 0.5084039</span>
<span class="co">#&gt; 9  chr22 17308363 17310225 1.333333 0.5773503</span>
<span class="co">#&gt; 10 chr22 17385314 17385395 1.000000        NA</span>
<span class="co">#&gt; # ... with 581 more rows</span></code></pre></div>
</div>
<div id="subtract" class="section level3">
<h3>Subtract</h3>
<p><code>bed_substract()</code> removes <code>x</code> intervals that intersect with <code>y</code>.</p>
<p><img src="README-subtract_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_subtract</span>(x, y)
<span class="co">#&gt; # A tibble: 724,003 × 3</span>
<span class="co">#&gt;     chrom start   end</span>
<span class="co">#&gt;    &lt;fctr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1    chr1  1379  2379</span>
<span class="co">#&gt; 2    chr1  2697  4252</span>
<span class="co">#&gt; 3    chr1 13133 14133</span>
<span class="co">#&gt; 4    chr1 21038 21082</span>
<span class="co">#&gt; 5    chr1 23698 24698</span>
<span class="co">#&gt; 6    chr1 29153 30153</span>
<span class="co">#&gt; 7    chr1 37940 38940</span>
<span class="co">#&gt; 8    chr1 40432 40852</span>
<span class="co">#&gt; 9    chr1 44472 45472</span>
<span class="co">#&gt; 10   chr1 45651 47129</span>
<span class="co">#&gt; # ... with 723,993 more rows</span></code></pre></div>
</div>
<div id="window" class="section level3">
<h3>Window</h3>
<p><code>bed_window()</code> identifies <code>y</code> intervals that intersect an expanded window of <code>x</code> intervals.</p>
<p><img src="README-window_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)

<span class="co"># a few intersections</span>
<span class="kw">bed_intersect</span>(x, y)
<span class="co">#&gt; # A tibble: 0 × 6</span>
<span class="co">#&gt; # ... with 6 variables: chrom &lt;chr&gt;, start.x &lt;int&gt;, end.x &lt;int&gt;,</span>
<span class="co">#&gt; #   start.y &lt;int&gt;, end.y &lt;int&gt;, .overlap &lt;int&gt;</span>

<span class="co"># can be expanded by casting a wider net</span>
<span class="kw">bed_window</span>(x, y, genome, <span class="dt">both =</span> <span class="fl">1e6</span>)
<span class="co">#&gt; # A tibble: 7 × 6</span>
<span class="co">#&gt;   chrom  start.x    end.x  start.y    end.y .overlap</span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1 chr10 59964124 59965124 59960431 59961431     1000</span>
<span class="co">#&gt; 2 chr11 83069781 83070781 82802163 82803163     1000</span>
<span class="co">#&gt; 3 chr12 81829263 81830263 82534844 82535844     1000</span>
<span class="co">#&gt; 4 chr18  9054851  9055851  9158972  9159972     1000</span>
<span class="co">#&gt; 5 chr18 42140197 42141197 41659806 41660806     1000</span>
<span class="co">#&gt; 6  chr3 62841128 62842128 62526478 62527478     1000</span>
<span class="co">#&gt; 7  chrY 33043197 33044197 32042567 32043567      370</span></code></pre></div>
</div>
<div id="closest" class="section level3">
<h3>Closest</h3>
<p><code>bed_closest()</code> identifies <code>y</code> intervals that are closest to <code>x</code>.</p>
<p><img src="README-closest_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)

<span class="kw">bed_closest</span>(x, y)
<span class="co">#&gt; # A tibble: 95 × 7</span>
<span class="co">#&gt;    chrom   start.x     end.x   start.y     end.y .overlap .distance</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;     &lt;int&gt;     &lt;int&gt;    &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  18492087  18493087  19390794  19391794        0    897707</span>
<span class="co">#&gt; 2   chr1  63756939  63757939  59741807  59742807        0  -4014132</span>
<span class="co">#&gt; 3   chr1 178467124 178468124 190411099 190412099        0  11942975</span>
<span class="co">#&gt; 4   chr1 190548070 190549070 190411099 190412099        0   -135971</span>
<span class="co">#&gt; 5   chr1 192736619 192737619 190411099 190412099        0  -2324520</span>
<span class="co">#&gt; 6   chr1 229322176 229323176 229502740 229503740        0    179564</span>
<span class="co">#&gt; 7   chr1 243698261 243699261 229502740 229503740        0 -14194521</span>
<span class="co">#&gt; 8  chr10   4006237   4007237   8375718   8376718        0   4368481</span>
<span class="co">#&gt; 9  chr10  34237419  34238419  30237621  30238621        0  -3998798</span>
<span class="co">#&gt; 10 chr10 109761141 109762141 116046585 116047585        0   6284444</span>
<span class="co">#&gt; # ... with 85 more rows</span></code></pre></div>
</div>
</div>
<div id="randomzing-intervals" class="section level2 tabset">
<h2>Randomzing intervals</h2>
<p><code>valr</code> provides methods for creating new random intervals or permutations of existing intervals:</p>
<ul>
<li><code>bed_random</code> generates random intervals from an input <code>genome</code>.</li>
<li><code>bed_shuffle</code> shuffles coordinates given a set of input intervals.</li>
<li>Random sampling of input intervals is done with <code>dplyr</code>.</li>
</ul>
<div id="random" class="section level3">
<h3>Random</h3>
<p><code>bed_random</code> generates random intervals from an input genome. The numbers of intervals from each <code>chrom</code> are proporitional to each chrom <code>size</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="fl">1e6</span>, <span class="dt">length =</span> <span class="fl">1e3</span>)
x
<span class="co">#&gt; # A tibble: 1,000,000 × 3</span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 166749241 166750241</span>
<span class="co">#&gt; 2   chrY   3026622   3027622</span>
<span class="co">#&gt; 3  chr22  40955151  40956151</span>
<span class="co">#&gt; 4   chrX 134507457 134508457</span>
<span class="co">#&gt; 5   chr4 132332641 132333641</span>
<span class="co">#&gt; 6   chr9  82958038  82959038</span>
<span class="co">#&gt; 7   chr2  44702096  44703096</span>
<span class="co">#&gt; 8   chr5   6589088   6590088</span>
<span class="co">#&gt; 9   chr6 170020806 170021806</span>
<span class="co">#&gt; 10 chr15  99745583  99746583</span>
<span class="co">#&gt; # ... with 999,990 more rows</span>

<span class="co"># numbers of sampled intervals are proportional to chrom size</span>
<span class="kw">group_by</span>(x, chrom) %&gt;%<span class="st"> </span><span class="kw">summarize</span>(<span class="dt">n =</span> <span class="kw">n</span>()) %&gt;%<span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(n))
<span class="co">#&gt; # A tibble: 25 × 2</span>
<span class="co">#&gt;    chrom     n</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 80948</span>
<span class="co">#&gt; 2   chr2 78780</span>
<span class="co">#&gt; 3   chr3 64465</span>
<span class="co">#&gt; 4   chr4 61729</span>
<span class="co">#&gt; 5   chr5 58348</span>
<span class="co">#&gt; 6   chr6 54956</span>
<span class="co">#&gt; 7   chr7 51035</span>
<span class="co">#&gt; 8   chrX 50033</span>
<span class="co">#&gt; 9   chr8 47191</span>
<span class="co">#&gt; 10  chr9 45712</span>
<span class="co">#&gt; # ... with 15 more rows</span></code></pre></div>
</div>
<div id="sample" class="section level3">
<h3>Sample</h3>
<p>Sampling can be done using <code>dplyr</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="co"># sample by number</span>
<span class="kw">sample_n</span>(x, <span class="fl">1e3</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; # A tibble: 1,000 × 3</span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1   chr6  88965026  88966026</span>
<span class="co">#&gt; 2   chr9  51878911  51879911</span>
<span class="co">#&gt; 3  chr17  71179161  71180161</span>
<span class="co">#&gt; 4   chr3  36709425  36710425</span>
<span class="co">#&gt; 5  chr10 111363341 111364341</span>
<span class="co">#&gt; 6   chr6 135120314 135121314</span>
<span class="co">#&gt; 7  chr14  66103281  66104281</span>
<span class="co">#&gt; 8   chr2 231848959 231849959</span>
<span class="co">#&gt; 9   chr9     44657     45657</span>
<span class="co">#&gt; 10  chr3 147527963 147528963</span>
<span class="co">#&gt; # ... with 990 more rows</span>

<span class="co"># or fraction</span>
<span class="kw">sample_frac</span>(x, <span class="fl">0.1</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; # A tibble: 100,000 × 3</span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1  chr15  11625869  11626869</span>
<span class="co">#&gt; 2   chr5  66811524  66812524</span>
<span class="co">#&gt; 3   chr4 173069294 173070294</span>
<span class="co">#&gt; 4   chr8  57675152  57676152</span>
<span class="co">#&gt; 5   chr7 147991552 147992552</span>
<span class="co">#&gt; 6   chr5  29351597  29352597</span>
<span class="co">#&gt; 7  chr14  60845266  60846266</span>
<span class="co">#&gt; 8   chr3  52885304  52886304</span>
<span class="co">#&gt; 9   chr5 166723494 166724494</span>
<span class="co">#&gt; 10  chr7 134445174 134446174</span>
<span class="co">#&gt; # ... with 99,990 more rows</span>

<span class="co"># or sample intervals within groups</span>
<span class="kw">group_by</span>(x, chrom) %&gt;%<span class="st"> </span><span class="kw">sample_n</span>(<span class="dv">1</span>)
<span class="co">#&gt; Source: local data frame [25 x 3]</span>
<span class="co">#&gt; Groups: chrom [25]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 210406322 210407322</span>
<span class="co">#&gt; 2  chr10 129085424 129086424</span>
<span class="co">#&gt; 3  chr11  51388305  51389305</span>
<span class="co">#&gt; 4  chr12 115055440 115056440</span>
<span class="co">#&gt; 5  chr13  13425723  13426723</span>
<span class="co">#&gt; 6  chr14  91377630  91378630</span>
<span class="co">#&gt; 7  chr15  23421155  23422155</span>
<span class="co">#&gt; 8  chr16   4002153   4003153</span>
<span class="co">#&gt; 9  chr17  67559067  67560067</span>
<span class="co">#&gt; 10 chr18  64362797  64363797</span>
<span class="co">#&gt; # ... with 15 more rows</span></code></pre></div>
</div>
<div id="shuffle" class="section level3">
<h3>Shuffle</h3>
<p><code>bed_shuffle</code> shuffles input intervals. Interval sizes are equal in the input and output.</p>
<p><img src="README-shuffle_glyph-1.png" width="384" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">bed_shuffle</span>(x, genome)
y
<span class="co">#&gt; # A tibble: 1,000,000 × 3</span>
<span class="co">#&gt;     chrom     start       end</span>
<span class="co">#&gt;    &lt;fctr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1    chr7  77526969  77527969</span>
<span class="co">#&gt; 2   chr10  50255096  50256096</span>
<span class="co">#&gt; 3   chr19  33432292  33433292</span>
<span class="co">#&gt; 4    chr6  47523906  47524906</span>
<span class="co">#&gt; 5   chr12 124017738 124018738</span>
<span class="co">#&gt; 6    chr6 101876439 101877439</span>
<span class="co">#&gt; 7    chr1 119218825 119219825</span>
<span class="co">#&gt; 8    chr3 184813716 184814716</span>
<span class="co">#&gt; 9    chr1 170167164 170168164</span>
<span class="co">#&gt; 10   chr2  17540570  17541570</span>
<span class="co">#&gt; # ... with 999,990 more rows</span>

<span class="kw">any</span>(x$start ==<span class="st"> </span>y$start)
<span class="co">#&gt; [1] FALSE</span>

<span class="kw">all</span>(x$end -<span class="st"> </span>x$start ==<span class="st"> </span>y$end -<span class="st"> </span>y$start)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
</div>
</div>
<div id="other-topics" class="section level2">
<h2>Other topics</h2>
<div id="grouping-related-intervals" class="section level3">
<h3>Grouping related intervals</h3>
<p>The <code>group_by</code> operation from <code>dplyr</code> serves a similar purpose to BEDtools <code>groupby</code>, and can be combined with <code>dplyr::summarize</code> to calculate summary statistics from groups.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_intersect</span>(x, y) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(chrom) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">overlap.total =</span> <span class="kw">sum</span>(.overlap))
<span class="co">#&gt; # A tibble: 24 × 2</span>
<span class="co">#&gt;    chrom overlap.total</span>
<span class="co">#&gt;    &lt;chr&gt;         &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1      25953477</span>
<span class="co">#&gt; 2  chr10      14054780</span>
<span class="co">#&gt; 3  chr11      13891909</span>
<span class="co">#&gt; 4  chr12      14053836</span>
<span class="co">#&gt; 5  chr13      11950117</span>
<span class="co">#&gt; 6  chr14      11132656</span>
<span class="co">#&gt; 7  chr15      10522156</span>
<span class="co">#&gt; 8  chr16       9387532</span>
<span class="co">#&gt; 9  chr17       8357097</span>
<span class="co">#&gt; 10 chr18       8175945</span>
<span class="co">#&gt; # ... with 14 more rows</span></code></pre></div>
</div>
</div>
</div>
<div id="interval-statistics" class="section level1 tabset">
<h1>Interval Statistics</h1>
<p><code>valr</code> provides several methods to assess statistical properties of interval sets including:</p>
<ul>
<li><code>bed_fisher()</code>: measure overlap significance of two sets of intervals.</li>
<li><code>bed_absdist()</code>: quantify absolute distance between query intervals and closest reference intervals</li>
<li><code>bed_reldist()</code>: quantify relative distances between query intervals and closest reference intervals</li>
<li><code>bed_jaccard()</code>: quantify extent of overlap between two sets of intervals</li>
</ul>
<p>Several of these methods were described in the <a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529">Genometricorr</a> software package.</p>
<div id="fishers-test" class="section level2">
<h2>Fisher’s test</h2>
<p>The Fisher’s test assesses whether two sets of intervals are drawn from the same background genome.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_fisher</span>(x, y, genome)
<span class="co">#&gt;   estimate p.value conf.low conf.high                             method</span>
<span class="co">#&gt; 1 2.347799       0 2.333782  2.361886 Fisher&#39;s Exact Test for Count Data</span>
<span class="co">#&gt;   alternative</span>
<span class="co">#&gt; 1   two.sided</span></code></pre></div>
</div>
<div id="absolute-distance" class="section level2">
<h2>Absolute distance</h2>
<p><code>bed_absdist()</code> computes the absolute distance between the midpoint of query intervals and the closest midpoints of a set of reference intervals. Absolute distances are scaled by the inter-reference gap for the chromosome as follows. For <code>Q</code> total query points and <code>R</code> reference points on a chromosome, scale the distance for each query point <code>i</code> to the closest reference point by the inter-reference gap for each chromosome.</p>
<p><span class="math display">\[
d_i(x,y) = min_{\substack{k}}(|q_i - r_k|)\frac{R}{Length\ of\ chromsome}
\]</span></p>
<p>By default both absolute and scaled distances are reported as <code>absdist</code> and <code>scaled_absdist</code> respectively.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_absdist</span>(x, y, genome)
<span class="co">#&gt; # A tibble: 1,000,000 × 5</span>
<span class="co">#&gt;    chrom start   end absdist scaled_absdist</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;          &lt;dbl&gt;</span>
<span class="co">#&gt; 1   chr1   445  1445    4841     1.57117978</span>
<span class="co">#&gt; 2   chr1  1822  2822    3464     1.12426498</span>
<span class="co">#&gt; 3   chr1  3355  4355    1931     0.62671931</span>
<span class="co">#&gt; 4   chr1  5563  6563     277     0.08990225</span>
<span class="co">#&gt; 5   chr1  6856  7856     926     0.30053966</span>
<span class="co">#&gt; 6   chr1  7150  8150     632     0.20511994</span>
<span class="co">#&gt; 7   chr1 14374 15374    1984     0.64392082</span>
<span class="co">#&gt; 8   chr1 20874 21874    3501     1.13627358</span>
<span class="co">#&gt; 9   chr1 22324 23324    4951     1.60688104</span>
<span class="co">#&gt; 10  chr1 24445 25445    3224     1.04637133</span>
<span class="co">#&gt; # ... with 999,990 more rows</span></code></pre></div>
</div>
<div id="relative-distance" class="section level2">
<h2>Relative distance</h2>
<p><code>bed_reldist()</code> computes the relative distance between a query interval and the two closest reference intervals. The relative distance can range between <code>[0,0.5]</code>. If the overall distribution of distances is biased toward zero, then the query and reference intervals tend to be closer in space (<a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529">17</a>). By default a summary with the frequency of each relative distance is reported.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_reldist</span>(x, y)
<span class="co">#&gt; # A tibble: 51 × 4</span>
<span class="co">#&gt;    reldist counts  total       freq</span>
<span class="co">#&gt;      &lt;dbl&gt;  &lt;int&gt;  &lt;int&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1     0.00  19776 999939 0.01977721</span>
<span class="co">#&gt; 2     0.01  20063 999939 0.02006422</span>
<span class="co">#&gt; 3     0.02  20054 999939 0.02005522</span>
<span class="co">#&gt; 4     0.03  19857 999939 0.01985821</span>
<span class="co">#&gt; 5     0.04  20085 999939 0.02008623</span>
<span class="co">#&gt; 6     0.05  20197 999939 0.02019823</span>
<span class="co">#&gt; 7     0.06  19816 999939 0.01981721</span>
<span class="co">#&gt; 8     0.07  20259 999939 0.02026024</span>
<span class="co">#&gt; 9     0.08  19973 999939 0.01997422</span>
<span class="co">#&gt; 10    0.09  19847 999939 0.01984821</span>
<span class="co">#&gt; # ... with 41 more rows</span></code></pre></div>
</div>
<div id="jaccard-similarity" class="section level2">
<h2>Jaccard similarity</h2>
<p><code>bed_jaccard()</code> quantifies the extent of overlap between to sets of intervals. The Jaccard statistic takes values of <code>[0,1]</code> and is measured as:</p>
<p><span class="math display">\[
J(x,y) = \frac{\mid x \bigcap y \mid}
              {\mid x \bigcup y \mid} 
       = 
         \frac{\mid x \bigcap y \mid}
              {\mid x \mid + \mid y \mid - \mid x \bigcap y \mid}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_jaccard</span>(x, y)
<span class="co">#&gt; # A tibble: 1 × 4</span>
<span class="co">#&gt;       len_i      len_u  jaccard      n</span>
<span class="co">#&gt;       &lt;int&gt;      &lt;int&gt;    &lt;dbl&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1 322941158 2000000000 0.192564 646741</span></code></pre></div>
</div>
</div>
<div id="benchmarks" class="section level1">
<h1>Benchmarks</h1>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># two sets of 1e6 random 1 kb intervals from hg19</span>
x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">library</span>(microbenchmark)
<span class="kw">microbenchmark</span>(
  <span class="kw">bed_random</span>(genome),
  <span class="kw">bed_closest</span>(x, y),
  <span class="kw">bed_intersect</span>(x, y),
  <span class="kw">bed_merge</span>(x),
  <span class="kw">bed_subtract</span>(x, y),
  <span class="kw">bed_complement</span>(x, genome),
  <span class="kw">bed_shuffle</span>(x, genome),
  <span class="dt">times =</span> <span class="dv">1</span>,
  <span class="dt">unit =</span> <span class="st">&#39;s&#39;</span>
)
<span class="co">#&gt; Unit: seconds</span>
<span class="co">#&gt;                       expr       min        lq      mean    median</span>
<span class="co">#&gt;         bed_random(genome) 0.1210124 0.1210124 0.1210124 0.1210124</span>
<span class="co">#&gt;          bed_closest(x, y) 4.6828317 4.6828317 4.6828317 4.6828317</span>
<span class="co">#&gt;        bed_intersect(x, y) 2.1265134 2.1265134 2.1265134 2.1265134</span>
<span class="co">#&gt;               bed_merge(x) 2.3916764 2.3916764 2.3916764 2.3916764</span>
<span class="co">#&gt;         bed_subtract(x, y) 2.3092343 2.3092343 2.3092343 2.3092343</span>
<span class="co">#&gt;  bed_complement(x, genome) 2.7562773 2.7562773 2.7562773 2.7562773</span>
<span class="co">#&gt;     bed_shuffle(x, genome) 0.9558835 0.9558835 0.9558835 0.9558835</span>
<span class="co">#&gt;         uq       max neval</span>
<span class="co">#&gt;  0.1210124 0.1210124     1</span>
<span class="co">#&gt;  4.6828317 4.6828317     1</span>
<span class="co">#&gt;  2.1265134 2.1265134     1</span>
<span class="co">#&gt;  2.3916764 2.3916764     1</span>
<span class="co">#&gt;  2.3092343 2.3092343     1</span>
<span class="co">#&gt;  2.7562773 2.7562773     1</span>
<span class="co">#&gt;  0.9558835 0.9558835     1</span></code></pre></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul>
      <li><a href="#overview">Overview</a><ul>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#comparison-to-other-tools">Comparison to other tools</a></li>
      <li><a href="#non-standard-evaluation">Non-standard evaluation</a></li>
      <li><a href="#getting-started">Getting started</a></li>
      </ul></li>
      <li><a href="#reading-data">Reading data</a><ul>
      <li><a href="#bed-files">BED files</a></li>
      <li><a href="#genome-files">Genome files</a></li>
      <li><a href="#bedgraph-files">bedGraph files</a></li>
      <li><a href="#vcf-files">VCF files</a></li>
      </ul></li>
      <li><a href="#interval-manipulations">Interval manipulations</a><ul>
      <li><a href="#single-set-operations">Single set operations</a></li>
      <li><a href="#multiple-set-operations">Multiple set operations</a></li>
      <li><a href="#randomzing-intervals">Randomzing intervals</a></li>
      <li><a href="#other-topics">Other topics</a></li>
      </ul></li>
      <li><a href="#interval-statistics">Interval Statistics</a><ul>
      <li><a href="#fishers-test">Fisher’s test</a></li>
      <li><a href="#absolute-distance">Absolute distance</a></li>
      <li><a href="#relative-distance">Relative distance</a></li>
      <li><a href="#jaccard-similarity">Jaccard similarity</a></li>
      </ul></li>
      <li><a href="#benchmarks">Benchmarks</a></li>
      </ul>
    </div>
      </div>

</div>


        <footer>
        <p>Built by <a href="http://hadley.github.io/staticdocs/">staticdocs</a>. Styled with <a href="http://getbootstrap.com">Bootstrap 3</a>.</p>
        </footer>
   </div>

  </body>
</html>
